---- 1. Bit Masking ---------

Bit masking ka funda simple hai—kisi bhi number ke specific bit(s) pe operation perform karna. 
Jaise Instagram kisi bhi photo pe black-and-white filter daal deta hai, 
waise hi bit masking ek filter ki tarah kaam karti hai jo hume specific bits pe control deti hai.

------ Why Use Bit Masking?
Koi specific bit check karni ho (0 hai ya 1).
Koi bit set (1) ya clear (0) karni ho.

Multiple bits pe simultaneously operation perform karna ho.

2. Find the ith Bit

Kisi bhi number ke ith bit ko find karne ke liye:

Mask Create karo: mask = (1 << i)
AND operation lagao: (num & mask)
Agar result non-zero aata hai, to ith bit = 1
Agar result zero aata hai, to ith bit = 0

Example
#include <iostream>
using namespace std;

bool findIthBit(int num, int i) {
    int mask = (1 << i);
    return (num & mask) != 0; // Non-zero -> bit is 1, otherwise 0
}

int main() {
    int num = 0b110101101; // 429 in decimal
    int i = 4;
    cout << "Bit at index " << i << ": " << findIthBit(num, i) << endl;
    return 0;
}
Output:

Bit at index 4: 0

------- 3. Set the ith Bit ------

Bit set karna matlab ith bit ko 1 banana. Simple hai—OR operation laga do mask ke saath.

Formula: num = num | (1 << i)

Example

#include <iostream>
using namespace std;

int setIthBit(int num, int i) {
    return num | (1 << i); // explained by striver 
}

int main() {
    int num = 0b110101101; // 429 in decimal
    int i = 4;
    cout << "New number after setting bit " << i << ": " << bitset<9>(setIthBit(num, i)) << endl;
    return 0;
}

Output:

New number after setting bit 4: 110111101

---------- 4. Clear the ith Bit --------

Bit clear karna matlab ith bit ko 0 banana. Iske liye mask ka complement banana padta hai.

Formula: num = num & ~(1 << i)

Example

#include <iostream>
using namespace std;

int clearIthBit(int num, int i) {
    int mask = ~(1 << i);
    return num & mask;
}

int main() {
    int num = 0b110101101; // 429 in decimal
    int i = 3;
    cout << "New number after clearing bit " << i << ": " << bitset<9>(clearIthBit(num, i)) << endl;
    return 0;
}


Output:

New number after clearing bit 3: 110100101


--------- 5. Find Number of Bits to Change to Convert a to b -------

Mujhe a ko b mein convert karna hai, to mujhe sirf wahi bits modify karni hain 
jo dono numbers mein alag hain. Yeh dekhne ka best way XOR operation hai.


Logic:

a ^ b ka result sirf un bits pe 1 dega jisme a aur b ke bits different hain.
Ab bas is result mein number of ones count karne hain.

-- Method 1: Naive Approach (Counting 1s in XOR Result)

a ^ b lo
Jab tak number zero na ho, last bit check kar ke count badhao.
num >> 1 se shift karke next bit check karo.

#include <iostream>
using namespace std;

int countBitsToChange(int a, int b) {
    int xorResult = a ^ b;
    int count = 0;

    while (xorResult) {
        count += (xorResult & 1); // Check last bit
        xorResult >>= 1; // Right shift
    }
    
    return count;
}

int main() {
    int a = 29, b = 15; // 11101 & 01111
    cout << "Bits to change: " << countBitsToChange(a, b) << endl;
    return 0;
}
Output:

Bits to change: 2


----  Method 2: Optimized Approach (n & (n-1)) ----

n & (n-1) ka funda hai ki yeh rightmost set bit ko remove kar deta hai.

Har baar n = n & (n-1) karte jao, jab tak n == 0 na ho.
Yeh method fast hai kyunki yeh sirf 1s ke count jitni baar chalta hai.

#include <iostream>
using namespace std;

int countBitsToChangeOptimized(int a, int b) {
    int xorResult = a ^ b;
    int count = 0;
    while (xorResult) {
        xorResult = xorResult & (xorResult - 1);
        count++;
    }
    return count;
}

int main() {
    int a = 29, b = 15; 
    cout << "Bits to change (optimized): " << countBitsToChangeOptimized(a, b) << endl;
    return 0;
}
Output:

Bits to change (optimized): 2


------ Key Takeaways -----

- Operation	 - Formula	  - Explanation
Find ith Bit	num & (1 << i)	Check ith bit (0 or 1)
Set ith Bit	`num	(1 << i)`
Clear ith Bit	num & ~(1 << i)	Ith bit ko 0 kar do
Find Bits to Change	count_ones(a ^ b)	XOR se different bits find karo

Extra Notes:
Time Complexity: Sabhi operations O(1) ya O(log n) hain.
Space Complexity: O(1) (Koi extra space nahi chahiye).
Use Cases: Cryptography, data compression, fast computations,
bitwise permissions (file access rights), etc.